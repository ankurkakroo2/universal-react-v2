
#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


#worker_connections is the number of simultaneous connections;
#visit https://docs.nginx.com/ for complete information
events {
    worker_connections  1024;  ## Default: 1024
}


http {
    include       mime.types;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0; #The zero value disables keep-alive client connections.
    keepalive_timeout  65;

    # Compression

    # Enable Gzip compressed.
    gzip on;

    # Compression level (1-9).
    # 5 is a perfect compromise between size and cpu usage, offering about
    # 75% reduction for most ascii files (almost identical to level 9).
    gzip_comp_level    5;

    # Don't compress anything that's already small and unlikely to shrink much
    # if at all (the default is 20 bytes, which is bad as that usually leads to
    # larger files after gzipping).
    gzip_min_length    256;

    # Compress data even for clients that are connecting to us via proxies,
    # identified by the "Via" header (required for CloudFront).
    gzip_proxied       any;

    # Tell proxies to cache both the gzipped and regular version of a resource
    # whenever the client's Accept-Encoding capabilities header varies;
    # Avoids the issue where a non-gzip capable client (which is extremely rare
    # today) would display gibberish if their proxy gave them the gzipped version.
    gzip_vary          on;

    # Compress all output labeled with one of the following MIME-types.
    # optimize gzip_types as per your requirement
    #gzip_types
        #application/atom+xml
        #application/javascript
        #application/json
        #application/ld+json
        #application/manifest+json
        #application/rss+xml
        #application/vnd.geo+json
        #application/vnd.ms-fontobject
        #application/x-font-ttf
        #application/x-web-app-manifest+json
        #application/xhtml+xml
        #application/xml
        #font/opentype
        #image/bmp
        #image/svg+xml
        #image/x-icon
        #text/cache-manifest
        #text/css
        #text/plain
        #text/vcard
        #text/vnd.rim.location.xloc
        #text/vtt
        #text/x-component
        #text/x-cross-domain-policy;
        # text/html is always compressed by HttpGzipModule

    # This should be turned on if you are going to have pre-compressed copies (.gz) of 
    # static files available. If not it should be left off as it will cause extra I/O 
    # for the check. It is best if you enable this in a location{} block for 
    # a specific directory, or on an individual server{} level. 
    # gzip_static on; 

    server {
        listen       80;
        server_name  localhost;

        #access_log  logs/host.access.log  main;

        location / {
            root   html; #change root folder path here, default is html
            index  index.html index.htm;
            try_files $uri $uri.html $uri/ 404;

            # like "location ~", but only for matching the original request. 
            # the redirect module provides an if directive which can check the $request_uri variable
            # if client requests "/" or "/abc" and 
            # the server internally redirects request to /index.html and abc.html accordingly
            if ($request_uri ~ /index(.html)?$) {
                rewrite ^(.*/)index(.html)?$ $1 permanent;
            }
            if ($request_uri ~ \.html$) {
                rewrite ^(.*)\.html$ $1 permanent;
            }

            # long cache policy on static assets
            # https://web.dev/uses-long-cache-ttl/#how-to-cache-static-resources-using-http-caching
            
            #location ~ ^/(static|_next/static) {
                #expires 365d;
            #}
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        #enable to allow POST request to static pages
        #error_page 405 = 200 $uri;
    }
    
    # HTTPS server
    # http://nginx.org/en/docs/http/configuring_https_servers.html

    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}
